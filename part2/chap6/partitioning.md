데이터를 파티셔닝 할때, 특정 파티션에 너무 많은 데이터가 저장된 경우를 `skewed` 라고 표현한다. 이 경우, 그리고 이러한 파티션을 `hot spot`이라고 부른다. `hot spot`을 줄이기 위해서, 데이터를 저장할때 랜덤하게 노드를 골라서 저장하는 방법이 있다. 하지만 쿼리할때 데이터가 어디있는지 모르므로 모든 노드에 쿼리를 실행해야 하므로 비효율적이다.

따라서 이를 해결하기 위한 첫번째 방법이 키의 범위로 파티셔닝하는 것이다.

키의 범위를 정하는 일은 사람이 직접할수도 있고, 시스템에서 자동으로 정할수 있다. 범위로 파티셔닝할때 주의할점은 키의 엑세스 패턴을 timestamp와 같은 값으로 설정할시 `hot spot` 들을 유발할수 있다는 단점이 있다. 따라서 범위를 신중하게 정하는것이 중요하다.

두번째 방법은 키를 해시한 값의 범위를 가지고 파티셔닝하는 것이다.

이 방법은 데이터를 모든 파티션에 골고루 분배할수 있다는 장점이 있다. 이때 해시함수는 특정 프로그래밍언어에서만 호환되는 해시함수를 써서는 안되고, 암호학적으로 강력할 필요는 없다. 이 방법은 range쿼리의 성능이 감소할수 있다는 약점이 있다. 기존에 인접해있던 데이터들은 이제 여러 파티션으로 흩어지기 때문이다. 이를 해결하기 위해서 일부 칼럼값을 가지고 해시해서 파티션을 결정하고 나머지 칼럼값으로 정렬하여 해당 파티션에 저장하는 방법이 있다.

위 두방법으로 hot spot을 줄인다고 해도, 근본적으로 특정 키로 읽기와 쓰기가 많이 발생하면 결국 특정 파티션으로 부하가 가해진다. 이를 해결하기 위해 이러한 특성의 몇몇 키에 대해서 키에 랜덤값을 붙이는 식으로 해서 여러 파티션으로 데이터가 저장되도록 할수 있다. 하지만 데이터를 읽을때 결국 랜덤값이 붙은 키값들을 받아와야하므로 이러한 키들을 어딘가에 저장을 해야할것이다. 따라서 읽기 부하가 증가하게 된다. 그러므로 쓰기 부하가 높은 키들에 대해서만 이러한 방식을 적용해야 한다.

다음은 세컨더리 인덱스로 파티셔닝하는 방법을 알아보자. 

첫번째 접근방법은 다큐먼트별로 세컨더리 인덱스를 구축하는 방법이 있다. 이 방법은 파티션별로 색인된 다큐먼트들을 대상으로 독립된 세컨더리 인덱스를 구축하는 방법이다. 이를 로컬 인덱스라고 하기도 한다. 이 방법은 모든 파티션을 대상으로 쿼리 해야한다는 단점이 있다. 이러한 방식은 scatter/gather 방식으로 불리기도 하며, 가장 느린 쿼리가 병목으로 작용할수 있다. 대부분의 디비 벤더들은 단일 파티션에만 쿼리할수 있도록 파티셔닝 스키마를 정의하라고 하지만, 여러 세컨더리 인덱스로 쿼리시 이는 불가능하다.

두번째 접근방법은 Term을 가지고 세컨더리 인덱스를 구축하는 방법이다. 이 방법은 모든 파티션에 있는 다큐먼트들을 대상으로 단일 세컨더리 인덱스를 구축하는 방법이다. 이를 글로벌 인덱스라고 하기도 한다. term으로 파티셔닝하는것은 레인지 스캔에 유리하고, term의 해시값으로 파티셔닝하는것은 데이터를 분산해서 저장하기 유용하다. 글로벌 인덱스의 장점은 단일 파티션에 쿼리하면 되므로 성능이 향상된다는 점이다. 그러나 쓰기작업이 복잡하고 느릴수 있다는 단점이 있다.

다음은 파티션 리벨런싱에 대해서 알아보자. 파티션 리벨런싱이란 하나의 노드에 있는 부하를 다른 클러스터에 있는 노드로 옮기는 과정을 말한다.

다음 세가지 조건을 최소한 만족해야 한다.

- 리벨런싱후, 부하는 노드들에 균등하게 분산되어야 한다.
- 리벨런싱 도중, 디비는 계속해서 읽기 쓰기 작업을 수행해야한다.
- 노드들 사이에 불필요한 데이터 이동이 발생해서는 안된다.

다음은 리벨런싱의 전략에 대해서 알아보자.

먼저 해시한 값에 mod N 연산을 취하여 파티션을 결정하는 간단한 방식을 차용하는건 좋은 생각이 아니다. 왜냐하면 N이 변하면 기존에 있던 데이터를 다시 새로운 노드로 옮겨야 하기 때문이다. 따라서 데이터를 필요이상으로 많이 옮길필요가 없는 방법이 필요하다.

첫번째 방법은 고정된 수의 파티션을 두는 방법이다. 이 방법은 노드가 추가될경우 기존 노드에 할당된 파티션들을 다른 노드에 할당하고, 노드수가 감소할때는 반대로 하는 방법이다. 이 방법은 파티션 수가 너무 많으면 리벨런싱이 너무 자주 일어나서 오버헤드를 유발하고, 파티션 수가 너무 적으면 리벨런싱과 failover시 오버헤드가 크므로 적절한 파티션 수를 설정해야 한다. 하지만 파티션수는 고정되있고 데이터셋 사이즈가 계속 변한다면 설정하기가 어렵다.

두번째 방법은 다이나믹 파티셔닝이다. 이 방법은 파티션에 할당된 데이터크기에 따라서 파티션을 쪼개거나 머지하는 방식으로 동작한다. 이 방식의 장점은 데이터 사이즈에 따라서 파티션의 수가 동적으로 변하는 것이다. 

세번째 방법은 노드수에 비례하여 파티셔닝하는 방법이다. 새로운 노드가 합류하게되면 기존에 존재하던 파티션들중 절반은 새로운 노드가 갖고 나머지 절반은 그대로 두는방식으로 동작한다.

리벨런싱은 수동으로 하는방법과 자동으로 하는방법이 있다. 자동으로 할경우, 편리하긴하지만 언제 리벨런싱을 할지 예측불가능할수 있다. 리벨런싱하는 동안 외부 요청에 대응하기 위한 퍼포먼스가 감소할수 있다. 따라서 사람이 직접 리벨런싱하는것이 더 안정적일수도 있다.

다음은 클라이언트의 리퀘스트를 라우팅하는 방법에 대해 알아보자. 다음의 세가지 방법이 있다.

1. 클라이언트는 임의의 노드에 요청을 보내고, 해당 노드가 요청을 직접 처리하든지 아니면 다른 노드에게 요청을 전달한다.
2. 클라이언트는 routing tier에게 요청을 보내고, routing tier는 적절한 노드를 찾아서 요청을 전달한다.
3. 클라이언트가 파티셔닝에 대해서 인지하고, 적절한 노드를 파악하여 요청을 보낸다.

많은 분산 데이터 시스템들이 ZooKeeper와 같은 시스템을 coordination system으로 사용한다.

Cassandra와 Riak의 경우 gossip protocol이라는걸 사용해서 외부 시스템에 대한 의존없이도 클러스터 상태변화를 감지한다.

